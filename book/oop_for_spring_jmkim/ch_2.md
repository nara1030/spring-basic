2장. 자바와 절차적/구조적 프로그래밍
=====
## 목차
1. [자바의 개발과 구동](#자바의-개발과-구동)
	* [T 메모리 구조](#T-메모리-구조)
	* [절차 및 구조적 프로그래밍 유산](#절차-및-구조적-프로그래밍-유산)
2. [객체 제외 메모리 사용 예제](#객체-제외-메모리-사용-예제)
	* [메서드 스택 프레임1](#메서드-스택-프레임1)
		* [JVM 전처리 작업](#메인-메서드가-실행되기-전-JVM에서-수행하는-전처리-작업들)
	* 변수와 메모리
	* 블록 구문과 메모리
	* 지역 변수와 메모리
	* 메서드 스택 프레임2
	* 전역 변수와 메모리
3. 기타
	* 멀티 스레드/멀티 프로세스의 이해

## 자바의 개발과 구동
자바 프로그램을 개발할 때, 구동할 때 각각 어떤 개발 도구가 필요한지 정리하면 아래와 같다.

| 현실 세계 | 자바 세계 | |
| :- | :-- | :-- |
| 소프트웨어 개발 도구 | JDK - 자바 개발 도구 | JVM용 소프트웨어 개발 도구 |
| 운영체제 | JRE - 자바 실행 환경 | JVM용 OS |
| 하드웨어 - 물리적 컴퓨터 | JVM - 자바 가상 기계 | 가상의 컴퓨터 |

JDK는 자바 소스 컴파일러인 `javac.exe`를 포함하고 있고, JRE는 자바 프로그램 실행기인 `java.exe`를 포함하고 있다. JRE는 프로그램 안에 `main()` 메소드가 있는지 확인한다. `main()` 메소드의 존재가 확인되면 JRE는 프로그램 실행을 위한 사전 준비에 착수한다. 가상의 기계인 JVM에 전원을 넣어 부팅하는 것이다. 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행한다. 이를 위해 JVM이 가장 먼저 하는 일을 전처리라고 한다.

##### [목차로 이동](#목차)

### T 메모리 구조

프로그램이 메모리를 사용하는 방식에 대해 도식화하면 아래와 같다.

* 프로그램이 메모리를 사용하는 방식  
	<img src="./img/program_memory_1.jpg" width="300" height="130"></br>
* 객체 지향 프로그램의 메모리를 사용하는 방식  
	<img src="./img/program_memory_2.jpg" width="300" height="130"></br>
	* 객체 지향 프로그램에서는 데이터 저장 영역을 세 개의 영역으로 분할 사용

변수의 종류에 따라 메모리(데이터 저장 영역)에 저장되는 위치가 다르다.

* 스택 영역
	* **지역 변수**는 스택 영역(스택 프레임 내부)에서 일생을 보냄
	* 스택 프레임이 사라지면 함께 소멸
* 스태틱 영역
	* **클래스 멤버 변수**는 스태틱 영역에서 일생을 보냄
	* JVM이 종료될 때까지 유지
* 힙 영역
	* **객체 멤버 변수**는 힙에서 일생을 보냄(`??`)
	* 객체와 함께 가비지 컬렉터라고 하는 힙 회수기에 의해 소멸
	
##### [목차로 이동](#목차)

### 절차 및 구조적 프로그래밍 유산
`객체 지향` 프로그래밍은 `절차적/구조적` 프로그래밍의 어깨를 딛고 있다. 따라서 절차적/구조적 프로그래밍이란 무엇인지 아는 것이 중요하다.

* 절차적 프로그래밍
	* `goto` 사용 금지
* 구조적 프로그래밍
	* 함수 사용 강제
		1. 중복 코드 제거
		2. 논리를 함수 단위로 분리
		3. `전역 변수`보다는 `지역 변수` 사용 권장

그렇다면 자바 언어에서 이러한 절차적/구조적 프로그래밍의 유산은 어디에 남아 있을까? 정답은 `메서드`다. 객체 지향에서 제어문이 존재할 수 있는 유일한 공간이 바로 메서드 내부이기 때문이다.
		
관련해서 자세한 내용에 관해서는 다음 [링크](https://github.com/nara1030/ThisIsJava/blob/master/docs/etc/programming_paradigm.md).

##### [목차로 이동](#목차)

## 객체 제외 메모리 사용 예제
프로그램이 실행될 때 메모리, 즉 T 메모리에 어떤 일이 일어나는지 생각해볼 필요가 있다.

### 메서드 스택 프레임1
가장 기본이자 필수적이라고 할 수 있는 `main()` 메소드에 대해 살펴본다.

```java
public class Start {
	public static void main(String[] args) {
		System.out.println("Hello OOP!!");
	}
}
```

위에서 JRE가 프로그램 내부에 `main()` 메소드의 존재를 확인하면 JVM을 부팅하고, JVM은 [전처리](#메인-메서드가-실행되기-전-JVM에서-수행하는-전처리-작업들)를 수행한다고 했다. 모든 전처리 과정이 완료된 T 메모리의 모습은 아래와 같다.

<img src="./img/preprocessing.jpg" width="350" height="150"></br>

이후 `main()` 메서드가 놀기 위해 스택 프레임(stack frame)이 스택 영역에 할당된다. 더 정확히 말하면 **여는 중괄호를 만날 때마다 스택 프레임이 하나씩** 생긴다.

<img src="./img/stack_frame_1.jpg" width="300" height="200"></br>

이후 메서드의 인자 args를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보해야 한다. 즉, 메서드 인자(들)의 변수 공간을 할당하는 것이다.

<img src="./img/stack_frame_2.jpg" width="300" height="200"></br>

이후 `main()` 메서드 안의 첫 명령문을 실행하게 된다.

<img src="./img/stack_frame_3.jpg" width="450" height="200"></br>

그리고 `main()` 메서드의 끝을 나타내는 닫는 중괄호와 만났을 때 스택 프레임이 소멸된다.

<img src="./img/stack_frame_4.jpg" width="350" height="200"></br>

### 메인 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들
* `java.lang` 패키지를 T 메모리의 스태틱 영역에 배치
* import된 패키지를 T 메모리의 스태틱 영역에 배치
* 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치
	
##### [목차로 이동](#목차)
